

#include <stdlib.h>
#include <stdint.h>
#include <arpa/inet.h>
#include <db.h>
#include <sys/ipc.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <semaphore.h>
#include <string.h>
#include <signal.h>
#include <time.h>
#include <sys/time.h>

#include "readingdb.h"
#include "util.h"

#define MAXRECS (((MAXQUERYSET) < (IPC_MAX_RECORDS)) ? (MAXQUERYSET) : (IPC_MAX_RECORDS))

sig_atomic_t do_shutdown = 0;
void sig_shutdown(int arg) {
  do_shutdown = 1;
}

struct {
  DB *dbp;
  char dbfile[128];
} dbs[MAX_SUBSTREAMS];

void db_open() {
  int i;
  for (i = 0; i < MAX_SUBSTREAMS; i++) {
    int ret;
    int oflags = DB_CREATE;

    if ((ret = db_create(&dbs[i[, NULL, 0)) != 0) {
      fprintf(stderr, "CREATE: %s", db_strerror(ret));
      exit(1);
    }

  if ((ret = dbp->open(dbp, 
                       NULL, DATABASE, NULL, DB_BTREE, oflags, 0644)) != 0) {
    dbp->err(dbp, ret, "%s", DATABASE);
    exit(1);
  }
  }
}


void query(DB *dbp, IPC *ipp) {
  int ret;
  DBT key, data;
  DBC *cursorp;
  struct rec_key k;
  struct rec_val v;
  struct ipc_command *c = ipp->shm;
  struct ipc_reply *r = ipp->shm;
  unsigned long long starttime, endtime;
  int streamid;
  memset(&key, 0, sizeof(key));
  memset(&data, 0, sizeof(data));
  
  streamid = c->args.query.streamid;
  starttime = c->args.query.starttime;
  endtime = c->args.query.endtime;

  /* set up the query key */
  k.stream_id = htonl(streamid);
  k.timestamp = htonl(starttime);
  key.data = &k;
  key.size = key.ulen = sizeof(k);
  key.flags = DB_DBT_USERMEM;
  data.data = &v;
  data.ulen = sizeof(v);

  r->reply = REPLY_QUERY;
  r->data.query.nrecs = 0;

  ret = dbp->cursor(dbp, NULL, &cursorp, 0);
  if (cursorp == NULL) {
    dbp->err(dbp, ret, "cursor");
    return;
  }

  // printf("query id: %u timestamp: %llu\n", streamid, c->args.query.starttime);
  if ((ret = cursorp->get(cursorp, &key, &data, DB_SET_RANGE)) != 0) {
    // printf("No results found\n");
    dbp->err(dbp, ret, "%s", DATABASE);
    cursorp->close(cursorp);
    return;
  }

  while ((ret = cursorp->get(cursorp, &key, &data, DB_NEXT)) == 0) {
    k = *((struct rec_key *)key.data);
    v = *((struct rec_val *)data.data);
    if (ntohl(k.stream_id) != streamid ||
        ntohl(k.timestamp) > endtime) {
      break;
    }
    r->data.query.pts[r->data.query.nrecs].timestamp = ntohl(k.timestamp);
    r->data.query.pts[r->data.query.nrecs].reading = v.reading;


    // printf("%i %f\n", ntohl(k.timestamp), v.reading);
    if (++r->data.query.nrecs == MAXRECS) {
      break;
    }
  }
  // printf("wrote %i records\n", r->data.query.nrecs);
  
  cursorp->close(cursorp);
}



int main(int argc, char **argv) {
  DB *dbp;
  IPC *ipp;
  struct {
    int queries, adds, syncs;
  } stats = {0,0,0};
  struct timeval last, now, delta;

  drop_priv();

  // open the database
  dbp = db_open();

  // initialize the mapped segment we use to talk to client processes
  ipp = ipc_open(O_CREAT , O_CREAT);
  if (!ipp) {
    printf("Could not initialize ipc; exiting\n");
    exit(1);
  }

  
  signal(SIGINT, sig_shutdown);
  gettimeofday(&last, NULL);
  while (!do_shutdown) {
    struct ipc_command *c = ipp->shm;    
    struct timespec ts;
    DBT key, data;
    memset(&key, 0, sizeof(key));
    memset(&data, 0, sizeof(data));

    /* make sure we check for a SIGINT ever 100ms */
    if (clock_gettime(CLOCK_REALTIME, &ts) == -1) 
      continue;
    ts.tv_nsec += 100000;  
    if (sem_timedwait(ipp->mutex_server, &ts) < 0)
      goto do_stats;

    // process the request
    // printf("Handling request, type %i\n", c->command);
    switch (c->command) {
    case COMMAND_QUERY:
      query(dbp, ipp);
      stats.queries ++;
      break;
    case COMMAND_ADD:
      key.data = &c->args.add.k;
      key.size = sizeof(struct rec_key);
      key.flags = DB_DBT_USERMEM;
      data.data = &c->args.add.v;
      data.size = sizeof(struct rec_val);
      data.flags = DB_DBT_USERMEM;
      dbp->put(dbp, NULL, &key, &data, 0);
      // no return code for adding data
      // printf("add %i %i %f\n", ntohl(c->args.add.k.stream_id), ntohl(c->args.add.k.timestamp), c->args.add.v.reading);
      stats.adds++;
      break;
    case COMMAND_SYNC:
      dbp->sync(dbp, 0);
      stats.syncs++;
      break;
    default:
      break;
    }
    sem_post(ipp->mutex_reply);

  do_stats:
    gettimeofday(&now, NULL);
    timeval_subtract(&delta, &now, &last);
    if (delta.tv_sec > 0) {
      float tps = stats.queries + stats.adds + stats.syncs;
      tps /= ((float)delta.tv_sec) + (((float)delta.tv_usec) / 1e6);
      printf("%li.%06lis: %0.2ftps queries: %i adds: %i syncs: %i\n",
             delta.tv_sec, delta.tv_usec, tps,
             stats.queries, stats.adds, stats.syncs);
      gettimeofday(&last, NULL);
      stats.queries = stats.adds = stats.syncs = 0;
    }
  }

  printf("Exiting\n");
  ipc_close(ipp);
  dbp->close(dbp, 0);
  return 0;
}
